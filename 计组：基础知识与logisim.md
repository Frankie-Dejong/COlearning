# 基础知识

## 进制

一个n位b进制数为一个具有n个字符的字符串（b~n-1~b~n-2~...b~1~b~0~)~b~ = $\sum_{i=0}^{n-1}$b~i~$\times$b^i^，其中b~i~的取值范围在0和b-1之间。其中b~i~称为第i位的位权。

缺省情况下默认一个数为十进制数，除了我们所熟悉的二进制数以外，出现十以上进制时为了不造成解读的困难采用英文字母来代替十以上的数。例如十六进制中的A,B,C,D,E,F分别代表十进制中的10到15这六个数。

为了将二进制，十六进制与十进制区分开来。在数前加上0b以表示二进制，0x以表示十六进制，例如0x5a为一个十六进制数，换算成十进制数为90。

## 进制转换

### 十进制与二、八、十六进制数的相互转化

对于二、八、十六进制向十进制的转换直接采用进制的定义（b~n-1~b~n-2~...b~1~b~0~)~b~ = $\sum_{i=0}^{n-1}$b~i~$\times$b^i^ 即可，例如0x5a表示90，0b10表示2。

对于十进制数向二、八、十六进制数的转换，根据C语言课上的经验可以采用迭代的方式进行计算。

例如将十进制转换为一个二进制数。如果向其他进制转换只需要将2替换成对应的进制数即可。

```c
int a[100];
int top = -1;
int main()
{
  int x = 7;
  while(x)
  {
    a[++top] = x%2;
    x/=2;
  }
  reverse(a); // 将a中的数字倒序输出即为x的二进制表示
  return 0;
}
```

### 二、八、十六进制之间的相互转化

二，八，十六都是2的幂次，转换起来非常的简单。

因为16 = 2^4^，所以在16进制的一位等于二进制的四位。（证明起来非常简单，假设处理二进制数的第4n到4n+3位数，且这些位数的权值都为1，他们转换成十进制时对于数字的贡献为2^4n^+...+2^4n+3^。提出一个2^4n^即为16^n^（2^0^+2^1^+2^2^+2^3^）,即对应16进制中的第n位的一个数 ，该位的位权即为0b1111,即0xF。）

因此，在将二进制转换为十六进制的时候，只需要将二进制数分为四个一组，并逐组转换为十六进制即可。

在将十六进制转化为二进制的过程可视为上述过程的逆过程，将每个十六进制数转化为对应的四位二进制数即可。

二进制与八进制的互相转换同理

八进制与十六进制互相转换时可以先转换到二进制再进行下一步转换。

## 原码、反码和补码

### 原码

原码牺牲了一个位置来表示数字的正负，最高位为0表示这个数是正数，最高位为1则表示这个数是负数。例如对于三位的原码，001表示1，101则表示 -1。但是这种表示方式下两个数的加法不能直接相加，并且对于0而言，有100和000两种表示方式，因此现在的计算机在存储整数时通常均采用补码。

n位的原码系统可以表示[-2^n-1^+1,2^n-1^-1]内的整数。

### 反码

设数制的位宽为n，如果将正数按位取反，就得到了对应的负数，例如在三位的反码系统中，001表示1，110则表示-1。值得注意的是最高位依旧是符号位，也就是说正数的最高位均为0。

同样的，0在反码系统中依然有这两种表示，即000和111。

这种表示方式的好处在于在进行加法运算时可以直接相加，但是两个正数的相加有可能产生溢出的现象，导致最高位（符号位）从0变成1，即在反码系统中变成了负数，因此现在很少采用这种方式进行计算。

值得注意的是，在反码系统中，如果两个同符号的数相加而符号改变，则发生了溢出现象。

### 补码

对于补码系统而言，第n位（最高位）不再表示2^n-1^，而是表示$-$2^n-1^，其余的部分与原码相同，因此对于一个n位的补码系统，它可以表示的数的范围为[-2^n-1^,2^n-1^-1]，例如一个三位的补码系统，100表示-4，而011表示3。

在补码的加法运算中，因进位而导致的溢出可以直接舍弃掉最高位，补码的本质是计算两者之和对于2^n^取模的结果，因此可以不处理溢出的情况。

对于一个负数而言，知道了它的绝对值之后可以将绝对值按位取反再加1，就得到了负数的补码。

如过已知一个负数的补码表示，要求该负数的绝对值的补码表示，则将该负数的补码按位取反再加1即可。

在判断补码的计算是否溢出时和反码相同，即两个同号数相加得到了一个异号数，则产生了溢出。在实际判断当中，设符号位产生的进位为carry~MSB~和carry~MSB-1~，则发生溢出当且仅当 carry~MSB~ $\bigoplus$ carry~MSB-1~ = 1。（注意：如果两者都为1，即都发生了进位，那么是两个异号数相加得到了一个正数的情况，不属于溢出）

### 浮点数

在浮点数中表示有效数字时采用原码，并非补码，需要特殊注意。而在表示浮点数的幂次时，采用的是移码表示。

# Logisim

## Wiring Library

[官方参考文档](https://www-cburch-com.vpn.buaa.edu.cn:8118/logisim/docs/2.7/en/html/libs/index.html)

### Tunnel

Tunnel 部件可以将输入和输出直接联系起来，跳过中间纷繁复杂的连线过程。同一个标签下的Tunnel彼此相连，等效于用导线连接。

对于每个标签，只允许有一个输入，但对输出的数量不作限制。

### Probe

可以显示对应线路数据值，可以对多位宽数据进行实时监控。

在对电路进行测试时广泛使用。

### Splitter

可以将一个多位的输入分割为多路输出，也可以将多路的输入转化为1个输出。 例如Splitter可以将一个6位宽的数据100110转换为100和110两个信号分别输出。

### Pull Resistor

对一个未知状态的输入可以将它强制上拉/下拉到1/0输出，也可以选择输出Error，对于多位宽的数据中对于某一位未知状态数据同理

### Clock

时钟组件,可以按频率输出高电平和低电平，在Simulate菜单可以选择是否自动运行时钟和运行时频率，在Attribute中可以选择时钟组件在一个循环内输出高低电平的持续时间。

默认不自动运行时钟，可以用Ctrl+T切换时钟的输出

### Constant

十六进制下的常数，注意：书写时采用十六进制，但在数据传输时依然是二进制，同时需要保证Data Bits大于存储常数所需的宽度。

### Power/Ground

即电路中的火线和地线，若数据有多位则均为1/0。可以用Constant代替。

### Transistor

分为P型（在线上有一个圆圈）和N型两种。有gate和source两路输入，drain一路输出。

即半导体，P型在gate为0时导通，N型在gate为1时导通。

### <img src="/Users/mac/Library/Application Support/typora-user-images/截屏2022-08-14 下午8.51.43.png" alt="截屏2022-08-14 下午8.51.43" style="zoom:50%;" />

### Transmission Gate

实际上即为一个P型晶体管和N型晶体管的集合，只有当两者都导通时该部件才导通。

<img src="/Users/mac/Library/Application Support/typora-user-images/截屏2022-08-14 下午9.00.57.png#pic_center" alt="截屏2022-08-14 下午9.00.57" style="zoom:50%;" />

### Bit Extender

可以将输入转换为其他位宽的数据进行输出，当位宽减小时保留低位，抛弃高位，当位宽增加时，可以选择在高位全补0或全补1。

其中，输入和输出的位宽均可以在对应的Attribute中调节。

也可以在Extension Type中选择Input，这时可以将一个1位的数据输入到input接口来决定补0或补1。如果选择了Sign，则会自动补齐输入的最高位。

## Gates Library

大部分与离散数学中所学习到的知识相同。

特殊的，Logisim提供了一个Controlled Buffer/Inverter的组件，可以通过一个input来进行控制，当input为1时与正常的部件无异，当input为0｜｜floating时，output为floating，input为Error时，output也为Error。

Logisim同样提供了奇偶检验器组件，多路输入下，若有奇数个1，则奇数检验器输出高电平，偶数检验器输出低电平，否则反之。需要注意的是，在仅有两路输入的情况下，奇偶检验器和XOR，XNOR组件行为相同，但是当存在多路输入的时候，仅在有一个1输入的时候XOR才会输出1，XNOR才会输出0，否则反之。

## Plexers Library

### Multiplexer

多路选择器，通过一个输入来决定选取0端或者1端的数据向下传输

### Demultiplexer

多路分配器，即多路选择器的相反功能，可以将输入端的数据传输到任意输出端

其余输出均为0或floating（取决于是否打开三态）

### Decoder

编码器，0输入多输出：

含有Enable接口和Select接口，右侧多个output接口，并从N端开始从0开始编号

Enable为0的情况下输出均为floating

否则Select接口输入的数据为几，编号为几的output输出1，其余输出0

### Priorder Encoder

 输出左侧输入中最大的1所在的编号。下方的Enable input可决定是否enable这个部件

特殊的，当部件被激活时，若输入中没有1，Enable Output为1，右侧的下方引脚输出0

若部件未被激活或输入中没有1，则输出均为floating

### Selector

将输入分为等长的，位宽为输出宽度的小组，高位补0；并可输出特定的小组（从0开始编号）

## Arithmetic Library

### Adder

加法器，但是提供了Cin和Cout(bit width == 1)接口来与其他加法器相连组成多位的加法器。

其中Cin来接受进位值，Cout为产生的溢出值，可传递给下一个与之相连的Adder的Cin进行加法运算。

如果有未知或错误的值出现，Adder将只进行低位的加法。

### Subtractor

减法器，输出为左上角减左下角减上面（虽然很土但是就是这个意思），如果计算出结果为负数那么将在South Edge输出一个1，否则输出0。

上面的一个input为1位，默认为0。

### Multiplier

乘法器，输出为两个输入相乘加上Cin的输入值，Cout为溢出的部分（例如一个8位的mulitiplier，Cout即为结果的第8-15位）

### Divider

被除数由两部分组成，分别是N向的数据位作为高位和West Edge，North End的数据位作为低位组成，West  Edge的South End作为除数输入，在输出上，East End输出整数相除结果，South End输出余数。

### Negator

保持最低位的1及低位的0不变，将高位取反

### Comparator

比较器，可以比较West Edge的N端是大于，等于还是小于S端，并在East Edge输出。

可以选择按无符号或二进制补码形式进行比较

### Shifter

移位器：包含五种功能

* Logical Left：向左移动指定位数，高位抛弃，低位补0
* Logical Right：向右移动指定位数，低位抛弃，高位补0
* Arithmetic Right：向右移动指定位数，低位抛弃，所补的高位与原数的最高位相同
* Rotate Left：向左移动指定位数，高位溢出值补到低位
* Rotate Right：向右移动指定位数，低位丢失值补到高位

### Bit Adder

输出输入中有多少位是1，如果输入中1的数量不固定，输出中将包含位置数据。例如若输入中有9或10或11个1，则输出将为10EE（9，10，11高位均是10，低位不同）

### Bit Finder

将最低位记为0并依次编号。并输出最高位1/0，最低位1/0（可在Type中选择）的编号。

South Edge输出一个一位宽的数据，表示是否找到目标位置。

如果再找到目标数字之前遇到了未知数据，则两个输出均将输出Error

## Memory

我们来讲几个重要且常用的部件

### Register

即寄存器，非常非常的重要，是时序电路中的核心元件。

关于这个最重要的部件有一句最重要的话：寄存器在**时钟的上升沿将**输入端的数据复制到输出端，**其余时刻保持不变！！！**

这也是时序逻辑成立的基础，可以将现在的输出作为下一个状态的输入，从而实现循环（即将现在的状态暂时寄存在寄存器内），并在下一个时钟上升沿更新状态。

本质是两个相反的D触发器（），详情请参见黑书。

### Counter

计数器，有很多花活（），但是目前我暂时只把他当计数器用。可以计算clock走过了多少个周期。如果默认状态下随着clock而增加，也可以随着clock而减小。

### RAM与ROM

RAM可读可写（本课程需要选择读写分离attribute）。可以在A端输入地址，在D端输入在该地址存入的内容。

ROM只可读不可写，有手动和文件导入两种存储形式。若是采用文件导入需要使用txt格式，并在文件头加上v2.0 raw语句

# 一些Logisim小技巧

## step simulation

可以在simulate菜单中选择（需要禁用掉simulate enabled），这样便可以慢慢的进行调试，这种调试方法在没遇到一个器件的时候都会停下，因此可以看到逻辑电路工作的过程

## circuit appearance

在调用子电路时经常会发现自动生成的子电路模块非常的丑陋，这时我们可以自己修改子电路的外观，右键选择该电路并点击circuit appearance即可。

## 初始化寄存器的数据

有些时候我们需要初始化寄存器的数据（默认为0），这是我们可以使用一个这样的电路。

![截屏2022-08-25 下午7.09.24](/Users/mac/Library/Application Support/typora-user-images/截屏2022-08-25 下午7.09.24.png)

将counter的位数设置为1，最大值设置为1。并选择stay at value选项。这样在第一个时钟周期时counter会

输出0，以后的周期则会输出1。这样在第一个周期时多路选择器会选择我们设置好的数据（这里是01）进行寄存器的初始化，在之后便会一直选择正常的输入（这里未画出）

## 如何等待一个周期来规避初始化周期

由上条我们可以知道，有些时候第一个周期会被用来初始化，那么在第一个周期的输入数据就会被忽略掉。这个时候我们需要让输入延后一个周期进行——我们依然可以通过Counter来设计这个电路。

![截屏2022-08-25 下午7.19.09](/Users/mac/Library/Application Support/typora-user-images/截屏2022-08-25 下午7.19.09.png)

在这个电路中，对于这个32位的输入我们打算每个周期由最低位到最高位依次输入到电路中。在这个模块中寄存器通过上述的方式进行了初始化，那么输入的最低位就会被忽略掉，为了规避这种现象，我们将上一个title中的init取反输入到该计数器的复位输入中，这样在第一个周期init输入0，计数器的复位模块会收到一个高电平的信号，从而将存储的数据清0（注意该复位器是异步复位，因此不需要等到下一个时钟上升沿的到来再修改Counter的数据）。而在之后的周期中该复位输入则会一直接受到低电平信号，从而让计算器从下一个周期开始正常计数，这样我们就相比公共的时钟延后了一个周期。

值得注意的是，在第一个周期，选择器依然选择了最低位的数据并输入到了后续的电路中，但是会被寄存器忽略掉。而从下一个周期开始，Counter重新从0计数，选择器接着从最低位开始输出，而初始化好的寄存器也将接收到这个输入。
